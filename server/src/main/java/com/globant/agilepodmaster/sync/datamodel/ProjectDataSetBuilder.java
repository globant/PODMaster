package com.globant.agilepodmaster.sync.datamodel;

import com.globant.agilepodmaster.sync.SyncContext;
import com.globant.agilepodmaster.sync.reading.PodsBuilder;
import com.globant.agilepodmaster.sync.reading.Reader;
import com.globant.agilepodmaster.sync.reading.ReleasesBuilder;

import org.springframework.util.StringUtils;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Locale;

import lombok.Getter;

public class ProjectDataSetBuilder implements PodsBuilder, ReleasesBuilder {

  @Getter
  private List<PodData> pods;

  @Getter
  private List<ReleaseData> releases;

  private SyncContext syncContext;

  private ReleaseData defaultRelease;

  private SprintData defaultSprint;

  public ProjectDataSetBuilder(SyncContext syncContext) {
    this.syncContext = syncContext;
    this.pods = new ArrayList<PodData>();
    this.releases = new ArrayList<ReleaseData>();
  }

  @SuppressWarnings("unchecked")
  public ProjectDataSetBuilder addReader(
      @SuppressWarnings("rawtypes") final Reader reader) {
    reader.readInto(this);
    return this;
  }


  public PodsBuilder addPod(String name) {
    return this;
  }

  public PodsBuilder addMember(String name, String role) {
    return this;
  }



  /**
   * Create a release if does not exists. If name is empty a "default" release
   * is created.
   */
  public ReleasesBuilder addRelease(String releaseName) {

    if (StringUtils.isEmpty(releaseName)) {

      for (ReleaseData release : releases) {
        if (release.isAutoGenerated()) {
          defaultRelease = release;
          break;
        }
      }

      if (defaultRelease == null) {
        defaultRelease = new ReleaseData("Default", true);
        releases.add(defaultRelease);
      }
      return this;
    }

    for (ReleaseData release : releases) {
      if (release.getName().equals(releaseName)) {
        defaultRelease = release;
        break;
      }
    }

    if (defaultRelease == null) {
      defaultRelease = new ReleaseData(releaseName, false);
      releases.add(defaultRelease);

    }
    return this;
  }

  public ReleasesBuilder addSprint(String name, String startDate, String endDate) {
    SprintData sprintData = new SprintData(name, defaultRelease.getSprints()
        .size() + 1, getDate(startDate), getDate(endDate));

    defaultRelease.getSprints().add(sprintData);
    defaultSprint = sprintData;

    return this;

  }

  public ReleasesBuilder addSprintTask(String issueKey, String summary,
      String type, String Status, String owner, String severity, String priority) {
    TaskData taskData = new TaskData();

    // TODO look for a better way to truncate
    taskData.setKey(issueKey.substring(0, Math.min(issueKey.length(), 100)));
    taskData.setName(summary.substring(0, Math.min(summary.length(), 100)));
    // TODO set the rest of the fields
    defaultSprint.getSprintTasks().add(taskData);
    return this;
  }

  public ReleasesBuilder addBacklogTask(String issueKey, String summary,
      String type, String Status, String owner, String severity, String priority) {

    TaskData taskData = new TaskData();

    // TODO look for a better way to truncate
    taskData.setKey(issueKey.substring(0, Math.min(issueKey.length(), 100)));
    taskData.setName(summary.substring(0, Math.min(summary.length(), 100)));
    // TODO set the rest of the fields
    defaultRelease.getBacklog().add(taskData);
    return this;
  }

  public ProjectDataSet build() {
    // TODO Calculate Sub tasks.
    // TODO Add members to tasks.
    //

    return new ProjectDataSet(pods, releases);
  }


  public void warnMessage(String message) {
    syncContext.warn(message);
  }

  public void infoMessage(String message) {
    syncContext.info(message);
  }

  public void errorMessage(String message) {
    syncContext.error(message);
  }

  // TODO do it independent of DataSource format
  private Date getDate(final String theDate) {
    Date date = null;
    try {
      date = new SimpleDateFormat("d/M/y", Locale.ENGLISH).parse(theDate);
    } catch (ParseException e) {
      syncContext.error("Invalid date format:{0}", theDate);
    }
    return date;
  }

}
