package com.globant.agilepodmaster.sync.datamodel;

import com.globant.agilepodmaster.sync.SyncContext;
import com.globant.agilepodmaster.sync.reading.PodsBuilder;
import com.globant.agilepodmaster.sync.reading.Reader;
import com.globant.agilepodmaster.sync.reading.ReleasesBuilder;

import org.springframework.util.StringUtils;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Locale;

import lombok.Getter;

/**
 * Builder to build a ProjectDataSet DTO.
 * @author jose.dominguez@globant.com
 *
 */
public class ProjectDataSetBuilder implements PodsBuilder, ReleasesBuilder {

  @Getter
  private List<PodData> pods;

  @Getter
  private List<ReleaseData> releases;

  private SyncContext syncContext;

  private ReleaseData defaultRelease;

  private SprintData defaultSprint;

  /**
   * Constructor.
   * @param syncContext synchonization context to log the process.
   */
  public ProjectDataSetBuilder(SyncContext syncContext) {
    this.syncContext = syncContext;
    this.pods = new ArrayList<PodData>();
    this.releases = new ArrayList<ReleaseData>();
  }

  /**
   * Builds the ProjectDataSet DTO. This process has 3 steps:
   * 1 - Gathering data form data sources from Readers.
   * 2 - Composing issue tree.
   * 3 - Linking task with member of Pods.
   * @return the ProjectDataSet DTO. 
   */
  public ProjectDataSet build() {
    // TODO Calculate Sub tasks.
    // TODO Add members to tasks.
    //
    return new ProjectDataSet(pods, releases);
  }  
    
  /**
   * Add Reader to this builder in order to read the data.
   * @param reader the Reader to add.
   * @return a ProjectDataSetBuilder with the Reader added.
   */
  @SuppressWarnings("unchecked")
  public ProjectDataSetBuilder addReader(
      @SuppressWarnings("rawtypes") final Reader reader) {
    reader.readInto(this);
    return this;
  }

  @Override
  public PodsBuilder addPod(String name) {
    return this;
  }

  @Override
  public PodsBuilder addMember(String firstName, String lastName, String email,
      String role) {
    return this;
  }

  @Override
  public ReleasesBuilder addRelease(String name) {
    
    /**
     * Add a release data. If release name is empty an autogenerated (with default
     * name) release is created or returned. The same happens if the name is not
     * found.
     */

    if (StringUtils.isEmpty(name)) {

      for (ReleaseData release : releases) {
        if (release.isAutoGenerated()) {
          defaultRelease = release;
          break;
        }
      }

      if (defaultRelease == null) {
        defaultRelease = new ReleaseData("Default", true);
        releases.add(defaultRelease);
      }
      return this;
    }

    for (ReleaseData release : releases) {
      if (release.getName().equals(name)) {
        defaultRelease = release;
        break;
      }
    }

    if (defaultRelease == null) {
      defaultRelease = new ReleaseData(name, false);
      releases.add(defaultRelease);

    }
    return this;
  }
  
  @Override
  public ReleasesBuilder addSprint(String name, String startDate, String endDate) {
    SprintData sprintData = new SprintData(name, defaultRelease.getSprints()
        .size() + 1, getDate(startDate), getDate(endDate));

    defaultRelease.getSprints().add(sprintData);
    defaultSprint = sprintData;

    return this;

  }
  
  @Override
  public ReleasesBuilder addSprintTask(String issueKey, String summary,
      String type, String status, String owner, String severity, String priority) {
    TaskData taskData = new TaskData();
    
    //TODO implement a builder for this.

    // TODO look for a better way to truncate
    taskData.setKey(issueKey.substring(0, Math.min(issueKey.length(), 100)));
    taskData.setName(summary.substring(0, Math.min(summary.length(), 100)));
    // TODO set the rest of the fields
    defaultSprint.getSprintTasks().add(taskData);
    return this;
  }

  @Override
  public ReleasesBuilder addBacklogTask(String issueKey, String summary,
      String type, String status, String owner, String severity, String priority) {
     //TODO implement a builder for this.

    TaskData taskData = new TaskData();

    // TODO look for a better way to truncate
    taskData.setKey(issueKey.substring(0, Math.min(issueKey.length(), 100)));
    taskData.setName(summary.substring(0, Math.min(summary.length(), 100)));
    // TODO set the rest of the fields
    defaultRelease.getBacklog().add(taskData);
    return this;
  }

  @Override
  public void warnMessage(String message) {
    syncContext.warn(message);
  }

  @Override
  public void infoMessage(String message) {
    syncContext.info(message);
  }

  @Override
  public void errorMessage(String message) {
    syncContext.error(message);
  }

  // TODO do it independent of DataSource format
  private Date getDate(final String theDate) {
    Date date = null;
    try {
      date = new SimpleDateFormat("d/M/y", Locale.ENGLISH).parse(theDate);
    } catch (ParseException e) {
      syncContext.error("Invalid date format:{0}", theDate);
    }
    return date;
  }

}
